# Secret Management

Best practices for handling sensitive configuration values.

## Overview

Secrets like API keys, database passwords, and tokens require special handling:

- Never commit secrets to version control
- Use environment variables or secret managers
- Rotate secrets regularly
- Limit access to production secrets

## Local Development

### Using .env Files

```bash
# .env.local (gitignored)
DATABASE_URL=postgres://localhost/myapp
JWT_SECRET=local-development-secret
API_KEY=dev-api-key
```

```typescript
const config = await defineConfig({
  schema,
  sources: [
    { type: 'file', path: './config/default.json' },
    { type: 'file', path: './.env.local', format: 'dotenv', optional: true },
    { type: 'env', prefix: 'APP_' },
  ],
});
```

### Git Configuration

```gitignore
# .gitignore
.env.local
.env.*.local
.env.development.local
.env.production.local
*.pem
*.key
credentials.json
```

## Production Secrets

### Environment Variables

The most common approach for production:

```typescript
sources: [
  { type: 'file', path: './config/default.json' },
  { type: 'file', path: './config/production.json' },
  { type: 'env', prefix: 'APP_' },  // Secrets from env vars
]
```

### AWS Secrets Manager

```typescript
import { definePlugin, registerPlugin } from 'zonfig';
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';

const awsSecretsPlugin = definePlugin({
  name: 'aws-secrets',
  async load(options: { secretId: string; region?: string }) {
    const client = new SecretsManagerClient({
      region: options.region ?? process.env.AWS_REGION ?? 'us-east-1',
    });

    const response = await client.send(
      new GetSecretValueCommand({ SecretId: options.secretId })
    );

    return JSON.parse(response.SecretString ?? '{}');
  },
});

registerPlugin(awsSecretsPlugin);

// Usage
const config = await defineConfig({
  schema,
  sources: [
    { type: 'file', path: './config/default.json' },
    { type: 'plugin', name: 'aws-secrets', options: { secretId: 'prod/myapp' } },
    { type: 'env', prefix: 'APP_' },
  ],
});
```

### HashiCorp Vault

```typescript
const vaultPlugin = definePlugin({
  name: 'vault',
  async load(options: { address: string; path: string }) {
    const token = process.env.VAULT_TOKEN;

    const response = await fetch(`${options.address}/v1/${options.path}`, {
      headers: { 'X-Vault-Token': token! },
    });

    const data = await response.json();
    return data.data.data;
  },
});

registerPlugin(vaultPlugin);
```

### Google Secret Manager

```typescript
import { SecretManagerServiceClient } from '@google-cloud/secret-manager';

const gcpSecretsPlugin = definePlugin({
  name: 'gcp-secrets',
  async load(options: { project: string; secret: string; version?: string }) {
    const client = new SecretManagerServiceClient();
    const name = `projects/${options.project}/secrets/${options.secret}/versions/${options.version ?? 'latest'}`;

    const [response] = await client.accessSecretVersion({ name });
    const payload = response.payload?.data?.toString();

    return JSON.parse(payload ?? '{}');
  },
});
```

## Schema Validation

Mark sensitive fields in your schema:

```typescript
const schema = z.object({
  database: z.object({
    url: z.string().url(),  // Contains password
    password: z.string().min(16),
  }),
  jwt: z.object({
    secret: z.string().min(32),  // Should be cryptographically secure
    privateKey: z.string(),  // PEM encoded key
  }),
  api: z.object({
    key: z.string().min(20),
  }),
});
```

## Secret Rotation

Design your config to support rotation:

```typescript
const schema = z.object({
  database: z.object({
    // Support both old and new during rotation
    url: z.string().url(),
    urlPrevious: z.string().url().optional(),
  }),
  jwt: z.object({
    // Multiple keys for rotation
    secrets: z.array(z.string().min(32)).min(1),
  }),
});
```

## CI/CD Integration

### GitHub Actions

```yaml
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1

      - name: Deploy
        env:
          APP_DATABASE_URL: ${{ secrets.DATABASE_URL }}
          APP_JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: npm run deploy
```

### Docker

```dockerfile
# Don't bake secrets into images
# Use runtime environment variables instead

FROM node:20-alpine
WORKDIR /app
COPY . .
RUN npm ci --production

# Secrets provided at runtime
CMD ["node", "dist/index.js"]
```

```bash
docker run \
  -e APP_DATABASE_URL="$DATABASE_URL" \
  -e APP_JWT_SECRET="$JWT_SECRET" \
  myapp
```

## Best Practices

1. **Never commit secrets** - Use .gitignore and pre-commit hooks
2. **Use secret managers** in production - AWS Secrets Manager, Vault, etc.
3. **Rotate regularly** - Design for rotation from the start
4. **Least privilege** - Only give access to secrets that are needed
5. **Audit access** - Log who accesses secrets and when
6. **Encrypt at rest** - Use encrypted secret storage
7. **Different secrets per environment** - Never use production secrets in development

## Example: Complete Setup

```typescript
import { defineConfig, z } from 'zonfig';

const schema = z.object({
  database: z.object({
    url: z.string().url(),
  }),
  jwt: z.object({
    secret: z.string().min(32),
  }),
  api: z.object({
    key: z.string(),
  }),
});

export async function loadConfig() {
  const isDev = process.env.NODE_ENV !== 'production';

  return defineConfig({
    schema,
    sources: [
      // Base config (no secrets)
      { type: 'file', path: './config/default.json' },

      // Development: use .env.local
      ...(isDev ? [
        { type: 'file', path: './.env.local', format: 'dotenv' as const, optional: true },
      ] : []),

      // Production: use AWS Secrets Manager
      ...(!isDev ? [
        { type: 'plugin', name: 'aws-secrets', options: { secretId: 'prod/myapp' } },
      ] : []),

      // Environment variables always have highest priority
      { type: 'env', prefix: 'APP_' },
    ],
  });
}
```

## Next Steps

- [Plugins](/docs/sources/plugins) - Create custom secret loaders
- [Environment Profiles](/docs/profiles) - Environment-specific configuration
