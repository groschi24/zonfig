import type { z } from 'zod';

interface EnvField {
  key: string;
  type: string;
  required: boolean;
  default?: unknown;
  description?: string;
}

/**
 * Convert camelCase to SCREAMING_SNAKE_CASE
 * poolSize -> POOL_SIZE
 * NODE_ENV -> NODE_ENV (already uppercase, unchanged)
 */
function toScreamingSnake(str: string): string {
  // If already all uppercase/underscores, return as-is
  if (/^[A-Z0-9_]+$/.test(str)) {
    return str;
  }
  // Convert camelCase to SCREAMING_SNAKE_CASE
  return str
    .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
    .toUpperCase();
}

/**
 * Convert path to environment variable name
 * server.port -> SERVER__PORT
 * database.poolSize -> DATABASE__POOL_SIZE
 * NODE_ENV -> NODE_ENV
 */
function pathToEnvKey(path: string, prefix: string = ''): string {
  const envKey = path
    .split('.')
    .map(toScreamingSnake)
    .join('__');

  return prefix ? `${prefix}${envKey}` : envKey;
}

/**
 * Extract fields from a Zod schema for env example generation
 */
function extractEnvFields(
  schema: z.ZodType,
  prefix: string = '',
  envPrefix: string = ''
): EnvField[] {
  const fields: EnvField[] = [];

  if ('shape' in schema && typeof schema.shape === 'object') {
    const shape = schema.shape as Record<string, z.ZodType>;

    for (const [key, value] of Object.entries(shape)) {
      const path = prefix ? `${prefix}.${key}` : key;

      // Recursively handle nested objects
      if ('shape' in value) {
        fields.push(...extractEnvFields(value, path, envPrefix));
      } else {
        fields.push(getEnvFieldInfo(value, path, envPrefix));
      }
    }
  }

  return fields;
}

/**
 * Get the type name from Zod _def (works with both Zod 3 and Zod 4)
 */
function getDefType(def: Record<string, unknown>): string {
  // Zod 4 uses 'type', Zod 3 uses 'typeName'
  const typeName = (def.type as string) || (def.typeName as string) || '';
  // Normalize to lowercase for comparison
  return typeName.toLowerCase().replace('zod', '');
}

/**
 * Get field information for env example
 */
function getEnvFieldInfo(zodType: z.ZodType, path: string, envPrefix: string): EnvField {
  let type = 'string';
  let required = true;
  let defaultValue: unknown;
  let description: string | undefined;

  let current = zodType;

  if ('_def' in current) {
    const def = current._def as unknown as Record<string, unknown>;
    const defType = getDefType(def);

    if (defType === 'optional') {
      required = false;
      current = def.innerType as z.ZodType;
    }

    if (defType === 'default') {
      required = false;
      defaultValue = typeof def.defaultValue === 'function'
        ? (def.defaultValue as () => unknown)()
        : def.defaultValue;
      current = def.innerType as z.ZodType;
    }

    if (def.description && typeof def.description === 'string') {
      description = def.description;
    }

    // Get type from unwrapped type
    const innerDef = ('_def' in current ? current._def as unknown : {}) as Record<string, unknown>;
    const innerType = getDefType(innerDef);

    switch (innerType) {
      case 'string':
        type = 'string';
        break;
      case 'number':
        type = 'number';
        break;
      case 'boolean':
        type = 'boolean';
        break;
      case 'enum':
        // Zod 4 uses 'entries', Zod 3 uses 'values'
        const enumValues = (innerDef.entries as string[]) || (innerDef.values as string[]) || [];
        type = `enum: ${enumValues.join(' | ')}`;
        break;
      default:
        type = innerType || 'unknown';
    }
  }

  const field: EnvField = {
    key: pathToEnvKey(path, envPrefix),
    type,
    required,
  };

  if (defaultValue !== undefined) field.default = defaultValue;
  if (description !== undefined) field.description = description;

  return field;
}

/**
 * Generate .env.example file content from a Zod schema
 */
export function generateEnvExample(
  schema: z.ZodType,
  options: { prefix?: string; includeComments?: boolean } = {}
): string {
  const { prefix = '', includeComments = true } = options;
  const fields = extractEnvFields(schema, '', prefix);
  const lines: string[] = [];

  if (includeComments) {
    lines.push('# Configuration Environment Variables');
    lines.push('# Generated by zonfig');
    lines.push('');
  }

  for (const field of fields) {
    if (includeComments) {
      // Add comment with description and type info
      const comments: string[] = [];

      if (field.description) {
        comments.push(`# ${field.description}`);
      }

      comments.push(`# Type: ${field.type}${field.required ? ' (required)' : ' (optional)'}`);

      lines.push(...comments);
    }

    // Add the env var line
    let value = '';
    if (field.default !== undefined) {
      value = String(field.default);
    } else if (field.type === 'string') {
      value = '';
    } else if (field.type === 'number') {
      value = '0';
    } else if (field.type === 'boolean') {
      value = 'false';
    }

    lines.push(`${field.key}=${value}`);
    lines.push('');
  }

  return lines.join('\n').trim() + '\n';
}
